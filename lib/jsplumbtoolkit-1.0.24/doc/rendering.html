<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <script src="/js/jquery.min.js"></script>
        <title>jsPlumb Toolkit - documentation</title>
        <link href="//fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet">
<link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="../css/main.css" rel="stylesheet">



        <link rel="stylesheet" href="../css/jsplumb-doc.css">
        <script src="/js/docs.js"></script>
    </head>

    <body>

        <!-- Fixed navbar -->
<div class="navbar navbar-top navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="../index.html"><img src="../img/logo-medium-jsplumb.png"></a>

        </div>

        <div class="navbar-collapse collapse nav-wrapper">
            <ul class="nav navbar-nav">
                <li><a href="../index.html#demos">DEMOS</a></li>
<li><a href="../doc/home.html">DOCS</a></li>
<li><a href="../apidocs/index.html">APIDOCS</a></li>

            </ul>

            <div class="social-nav hidden-xs">
                <!--a href="#" class="link"><span class="icon-facebook"></span></a-->
<a href="http://twitter.com/jsplumblib" class="link"><span class="icon-twitter"></span></a>
<a href="http://github.com/sporritt/jsplumb/" class="link"><span class="icon-github"></span></a>
<a href="http://www.linkedin.com/company/jsplumb" class="link"><span class="icon-linkedin"></span></a>

            </div>
        </div><!--/.nav-collapse -->
    </div>
</div>


        <div class="container padding-top">
            <div class="row" id="docs">
                <div class="docs-nav col-xs-3" tabindex="0">
                    <ul>
<li><a href="home.html">Home</a></li>
<li><a href="getting-started.html">Getting Started</a></li>
<li><a href="basic-concepts.html">Basic Concepts</a>
    <ul>
        <li><a href="basic-concepts.html#instantiating">Instantiating the Toolkit</a></li>
        <li><a href="basic-concepts.html#basicloading">Loading Data</a></li>
        <li><a href="basic-concepts.html#rendering">Rendering</a></li>
    </ul>
</li>  
<li><a href="data-model.html">Data Model</a>
    <ul>
        <li><a href="data-model.html#format">Data Format</a></li>
        <li><a href="data-model.html#node-edge-port-id">Node, Edge and Port IDs</a></li>
        <li><a href="data-model.html#node-edge-port-type">Node, Edge and Port Type</a></li>
        <li><a href="data-model.html#datafactories">Data Factories</a></li>
    </ul>
</li>  
<li><a href="rendering.html">Rendering</a>
<ul>
    <li><a href="models-and-views.html">Models and Views</a></li>
    <li><a href="templating.html">Templating</a></li>
    <li><a href="layouts.html">Layouts</a></li>
    <li><a href="ui-states.html">UI States</a></li>
    <li><a href="path-tracing.html">Path Tracing</a></li>
    <li><a href="rendering.html#dragpalette">Drag & Drop Nodes</a></li>
    <li><a href="navigation.html">Navigating your Dataset</a></li>
</ul>
</li>
<li>
Data Management
    <ul>
        <li><a href="loading-and-saving-data.html">Loading & Saving Data</a></li>
        <li><a href="loading-and-saving-data.html#loading">Loading</a></li>
        <li><a href="updating-data.html">Updating Data</a></li>
    </ul>
</li>
    
<li><a href="css.html">CSS</a>
    <ul>
        <li><a href="css.html#defaultcss">Default CSS Stylesheet</a></li>
        <li><a href="css.html#ref">Class Reference</a></li>
    </ul>
</li>
  
<li><a href="events.html">Events</a>
    <ul>
        <li><a href="events.html#toolkit">Toolkit Events</a></li>
        <li><a href="events.html#surface">Rendering Events</a></li>
    </ul>
</li>
  
<li>Selecting Content
    <ul>
      <li><a href="selections.html">Selections</a></li>
      <li><a href="paths.html">Paths</a></li>
      <li><a href="filters.html">Filters</a></li>
    </ul>
</li>

<li><a href="angular-integration.html">Angular Integration</a></li>
<li>Demonstrations
    <ul>
      <li><a href="demo-hierarchical.html">Hierarchical Layout</a></li>
      <li><a href="demo-spring.html">Spring Layout</a></li>
      <li><a href="demo-imageWidget.html">Image Widget</a></li>
      <li><a href="demo-circular.html">Circular Layout</a></li>
      <li><a href="demo-multiple.html">Multiple Renderers</a></li>
      <li><a href="demo-paths.html">Path Tracing</a></li>
      <li><a href="demo-absolute.html">Absolute Layout</a></li>
      <li><a href="demo-database-visualizer.html">Database Visualizer</a></li>
      <li><a href="demo-flowchart-builder.html">Flowchart Builder</a></li>
      <li><a href="demo-angular.html">Angular Integration</a></li>
      <li><a href="demo-hello-world.html">Hello World</a></li>
    </ul>
</li>
    
<li><a href="UtilityFunctions.html">Utilities</a></li>
<li><a href="dialogs.html">Dialogs</a></li>
<li><a href="drawing.html">Drawing</a></li>
</ul>
                </div>
                <div class="markdown-body col-xs-9">
                    <h2>Rendering</h2>

<p><a id="top"></a></p>

<p>To view the data managed by an instance of the jsPlumb Toolkit, you must arrange for it to be rendered.  The Toolkit 
can render its data to an arbitrary number of elements, and each renderer is backed with its own instance of jsPlumb. 
The component used by the Toolkit to render is known as a <strong>Surface</strong>.  It supports pan/zoom/select, and has the 
ability to save and load its state locally in the user&#39;s browser.</p>

<p>Before reading this section it is important that you are thoroughly acquainted with the <a href="Data%20Model.html">data model</a> 
used by the Toolkit. It would also be useful to be have at least a basic knowledge of <a href="../community/home.html">jsPlumb</a>, 
since the appearance of Endpoints and Connections is jsPlumb&#39;s responsibility and you&#39;ll want to learn the syntax.</p>

<ul>
<li><a href="#configuring">Configuring a Surface</a></li>
<li><a href="#multiple">Rendering to Multiple Elements</a></li>
<li><a href="#surface">Surface Widget</a>

<ul>
<li><a href="#surface-zoom">Zooming</a></li>
<li><a href="#surface-pan">Panning</a></li>
<li><a href="#surface-select">Selecting Nodes</a></li>
<li><a href="#surface-background">Background Images</a></li>
<li><a href="#visibility">Hiding/Showing Elements</a></li>
</ul></li>
<li><a href="#dragging-nodes">Dragging Nodes</a>

<ul>
<li><a href="#dragging-nodes-filters">Drag Filters</a></li>
<li><a href="#dragging-nodes-posses">Drag Posses</a></li>
</ul></li>
<li><a href="#miniview">Miniview Widget</a></li>
<li><a href="Templating.html">Templating</a>

<ul>
<li><a href="Templating.html#connectivity">Configuring Connectivity</a></li>
</ul></li>
<li><a href="#saverestore">Saving and Restoring State</a></li>
<li><a href="#dragpalette">Dragging Nodes from a Palette</a>

<ul>
<li><a href="#dragnative">Dragging Native Objects</a></li>
</ul></li>
<li><a href="#misc">Miscellaneous</a>

<ul>
<li><a href="#misc">Suspending Event Consumption</a></li>
<li><a href="#disable">Disabling a Surface</a></li>
<li><a href="#ie8">IE8 Limitations</a></li>
</ul></li>
</ul>

<p><a name="configuring"></a></p>

<h3>Configuring a Surface</h3>

<p>To configure a Surface, call the <code>render</code> method on an existing Toolkit instance.  This can be done at any time - before or after data is loaded:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">myToolkit</span> <span class="o">=</span> <span class="nx">jsPlumbToolkit</span><span class="p">.</span><span class="nx">newInstance</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">myToolkit</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElementId&quot;</span><span class="p">,</span>
  <span class="p">...</span> <span class="nx">other</span> <span class="nx">options</span> <span class="p">...</span>
<span class="p">});</span>
</code></pre></div>
<p>The <code>render</code> method returns a Surface object. It is important to remember that for view related functionality you use a Surface object, whereas for operations on the 
data model you use a jsPlumb Toolkit instance.  Operations on the data model are reflected in all registered Surfaces 
for the specific instance of the jsPlumb Toolkit as they occur. If you wish to add a Node to the data model, 
for instance, you need to call <code>addNode</code> on a Toolkit instance. If you want to center the view in some element, 
you would call <code>centerContent</code> on the Surface registered for that element.</p>

<p>There are two required parameters to a <code>render</code> call: <code>container</code> and <code>palette</code>.</p>

<h4>Container</h4>

<p>For anyone who has used jsPlumb, the <code>container</code> parameter is probably familiar (and it&#39;s perhaps useful to know that the Toolkit passes <code>container</code> into the jsPlumb instance backing the Surface as the <code>Container</code> for that instance of jsPlumb). This is the element to be used as the parent for every element added by the Surface.  In addition, all artefacts added to the UI by the associated jsPlumb instance will have this element as their parent.  For a deeper discussion of this, see <a href="../community/home.html#container">the jsPlumb documentation</a>.</p>

<p><a id="palette"></a></p>

<h3>Palette</h3>

<p>A Palette contains configuration information for all of the Nodes, Ports and Edges in your UI; it is what you use to define the appearance and behaviour of the various parts of your UI, and also offers event binding to numerous lifecycle events. For a full discussion of Palettes, see <a href="palettes.html">here</a>.</p>

<p><a id="multiple"></a></p>

<h3>Rendering to Multiple Elements</h3>

<p>You can call <code>render</code> as many times as you like on a single Toolkit instance.  If the target container already has a Surface, that Surface is discarded. Every Surface that an instance of the Toolkit is tracking will be notified of changes to the data model.</p>

<p><a id="surface"></a></p>

<h3>The Surface Widget</h3>

<p>For a full discussion of the capabilities and usage of the Surface widget, see <a href="widget-surface.html">this page</a>. Here on this page we provide a short summary of its features.</p>

<p>Surface is a widget with several nice features:</p>

<p><a name="surface-zoom"></a>
- <strong>Zoom</strong></p>

<p>Change the zoom using the mouse wheel, pinch (on touch devices), right click + mouse move, or programmatically.</p>

<p><a name="surface-pan"></a>
- <strong>Pan/Drag</strong></p>

<p>Click/tap and hold then drag the contents around.  The Surface also, by default, provides &#39;nudge&#39; bars on the edges of 
the work area, which you can click to pan the contents by a given amount automatically, or click and hold to pan 
continuously. These nudge bars can be programmatically suppressed or simply hidden via CSS.</p>

<ul>
<li><strong>Save/Restore state</strong></li>
</ul>

<p>By default, the Surface writes the current position of elements contained to local storage. When the user comes back 
to a page that they have already viewed, these saved positions are used to restore the UI to the state it was in when 
they left it.  The current zoom and pan position are also saved and restored. This behaviour can be set to automatic or manual.</p>

<p><a name="surface-select"></a>
- <strong>Node Select</strong></p>

<p>In select mode, click/tap and drag to lasso a group of Nodes. Hold down the shift key to add to the current selection. 
When you drag from left to right you need only intersect some Node to select it. When you drag from right to left you 
must fully enclose a Node before it is selected.</p>

<p><a name="surface-background"></a>
- <strong>Background Images</strong></p>

<p>You can supply a background image for a Surface widget to display. You can also use a tiled image.</p>

<p><a href="#top">[top]</a></p>

<hr>

<p><a name="visibility"></a></p>

<h3>Hiding/Showing Elements</h3>

<p>The Surface widget has a <code>setVisible</code> method that takes a variety of arguments:</p>

<ul>
<li>a <a href="data-model.html">Node/Port</a> id</li>
<li>a DOM Element</li>
<li>a <a href="data-model.html">Node/Port/Edge</a></li>
<li>a <a href="selections.html">Selection</a></li>
<li>a <a href="paths.html">Path</a></li>
<li>a Toolkit instance</li>
</ul>

<p>..or an array of any of these. When you hide a Node, any Edges connected to that Node are also hidden. When you make a Node
visible, only Edges that are not connected to a hidden Node are made visible.</p>

<p>Say you want to select and hide a few Nodes, for instance (assume, in these example, the existence of a <code>toolkit</code> and 
a <code>surface</code> widget):</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">sel</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">select</span><span class="p">([</span><span class="s2">&quot;node1&quot;</span><span class="p">,</span> <span class="s2">&quot;node2&quot;</span><span class="p">]);</span>
<span class="nx">surface</span><span class="p">.</span><span class="nx">setVisible</span><span class="p">(</span><span class="nx">sel</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div>
<p>or perhaps you want to select the Path from some node to another and then hide it:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">getPath</span><span class="p">({</span> <span class="nx">source</span><span class="o">:</span><span class="s2">&quot;node1&quot;</span><span class="p">,</span> <span class="nx">target</span><span class="o">:</span><span class="s2">&quot;node23&quot;</span> <span class="p">});</span>
<span class="nx">surface</span><span class="p">.</span><span class="nx">setVisible</span><span class="p">(</span><span class="nx">sel</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div>
<p>Or maybe even you just want to hide a DOM element that you got through jQuery and you don&#39;t need to know what 
its underlying Node is:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;aContainerElement&quot;</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="s2">&quot;aNodeSelector&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">surface</span><span class="p">.</span><span class="nx">setVisible</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p><a href="#top">[top]</a></p>

<hr>

<p><a name="dragging-nodes"></a></p>

<h3>Dragging Nodes</h3>

<p>The vast majority of applications using the Toolkit will want to support dragging of Nodes in the Surface. For this
reason, dragging is automatically enabled for any Nodes in your UI.</p>

<p>The Toolkit uses, via jsPlumb, <a href="https://github.com/jsplumb/katavorio">Katavorio</a> to support dragging.</p>

<h4>Switching off Dragging</h4>

<p>To switch off dragging:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">myToolkitInstance</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElement&quot;</span><span class="p">,</span>
  <span class="nx">view</span><span class="o">:</span><span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
  <span class="nx">elementsDraggable</span><span class="o">:</span><span class="kc">false</span>
<span class="p">});</span>
</code></pre></div>
<h4>Drag Options</h4>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">myToolkitInstance</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElement&quot;</span><span class="p">,</span>
  <span class="nx">view</span><span class="o">:</span><span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
  <span class="nx">dragOptions</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">start</span><span class="o">:</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">},</span>
    <span class="nx">drag</span><span class="o">:</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">},</span>
    <span class="nx">stop</span><span class="o">:</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<h5>Dragging on a grid</h5>

<p>Katavorio supports constraining dragged elements to a grid:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">myToolkitInstance</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElement&quot;</span><span class="p">,</span>
  <span class="nx">view</span><span class="o">:</span><span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
  <span class="nx">dragOptions</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">grid</span><span class="o">:</span><span class="p">[</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span> <span class="p">]</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><a href="#top">[top]</a></p>

<hr>

<p><a name="dragging-nodes-filters"></a></p>

<h4>Drag Filters</h4>

<p><a name="dragging-nodes-posses"></a></p>

<h4>Drag Posses</h4>

<p>A drag <code>Posse</code> is a set of Nodes that should always be dragged as a unit. Unlike in a <code>group</code> (an as-yet unsupported
concept, in which a set of Nodes share a common element as parent, which is collapsible etc), these Nodes do not 
necessarily have any visual indication that they belong together (although you could achieve that using a 
<a href="layouts.html#decorators">decorator</a>.</p>

<p>Any given Node can belong to multiple Posses at a time. Additionally, each Node&#39;s participation in a Posse is either 
<em>active</em>, in which dragging the Node causes all Nodes in the Posse to be dragged, or <em>passive</em>, in which the Node
 drags independently but is dragged when one of the Posse&#39;s active Nodes is dragged.</p>

<h5>Configuring a Posse</h5>

<p>Nodes are assigned to a Posse via an optional <code>assignPosse</code> function that you provide to a <code>render</code> method call:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"> <span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">myToolkitInstance</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
   <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElement&quot;</span><span class="p">,</span>
   <span class="nx">view</span><span class="o">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
   <span class="nx">assignPosse</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">parentId</span> <span class="o">||</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><strong>Note</strong> the object passed to <code>assignPosse</code> is a Toolkit <code>Node</code> object; its backing data is available via the <code>data</code>
property.</p>

<p>This posse assign function returns either the <code>parentId</code> of the Node&#39;s data, or just the Node&#39;s <code>id</code>. So we&#39;re saying
 that the Posse consists of some &quot;parent&quot; node and any other nodes marked as &quot;children&quot; of the node. An example few nodes
 conforming to this data model might be:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"> <span class="p">[</span>
   <span class="p">{</span>
     <span class="s2">&quot;id&quot;</span><span class="o">:</span><span class="s2">&quot;001&quot;</span><span class="p">,</span>
     <span class="s2">&quot;foo&quot;</span><span class="o">:</span><span class="s2">&quot;FOO&quot;</span>
   <span class="p">},</span>
   <span class="p">{</span>
     <span class="s2">&quot;id&quot;</span><span class="o">:</span><span class="s2">&quot;z59-b&quot;</span><span class="p">,</span>
     <span class="s2">&quot;parentId&quot;</span><span class="o">:</span><span class="s2">&quot;001&quot;</span><span class="p">,</span>
     <span class="s2">&quot;foo&quot;</span><span class="o">:</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span>
   <span class="p">},</span>
   <span class="p">{</span>
     <span class="s2">&quot;id&quot;</span><span class="o">:</span><span class="s2">&quot;qx-78&quot;</span><span class="p">,</span>
     <span class="s2">&quot;parentId&quot;</span><span class="o">:</span><span class="s2">&quot;001&quot;</span><span class="p">,</span>
     <span class="s2">&quot;foo&quot;</span><span class="o">:</span><span class="s2">&quot;ok&quot;</span>
   <span class="p">}</span>
 <span class="p">]</span>
</code></pre></div>
<p>If <code>assignPosse</code> returns null then the relevant Node is not added to a Posse. Note that in this case if there were
any &quot;parent&quot; nodes that had no &quot;children&quot; then they would just be in a Posse of one. That&#39;s ok; a bit boring, perhaps,
around the campfire, but ok.</p>

<h5>Active Nodes and Passive Nodes</h5>

<p>In the previous example we returned a String to identify the Posse to which each Node belongs. This indicates that the
 Node should play an <em>active</em> role in the Posse, ie. when it is dragged, all Nodes in the Posse are dragged:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">assignPosse</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">parentId</span> <span class="o">||</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>You can, however, pass back an array in which the second argument indicates whether or not the Node should be <em>active</em>:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">assignPosse</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">parentId</span>  <span class="o">?</span> <span class="p">[</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">parentId</span><span class="p">,</span> <span class="kc">false</span> <span class="p">]</span> <span class="o">:</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>In this second example we check if a Node has a <code>parentId</code>. If so, the Node is added to the Posse with that value, but
 as a <em>passive</em> Node: dragging it will not cause the other Nodes to be dragged. Otherwise if there is no <code>parentId</code>
 then the Node is a parent and it is added as a <em>master</em> to its own Posse.</p>

<h5>Adding Nodes Manually</h5>

<p>You can at any time manually add a Node to a Posse with this method:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">addToPosse</span><span class="p">(</span><span class="nx">aNode</span><span class="p">,</span> <span class="nx">posseId</span><span class="p">);</span>
</code></pre></div>
<p><code>aNode</code> may be the ID of a Node, an actual Node, a DOM element representing a Node, or a list-like object of any of these.
Note here that the method is on the Surface widget and not on the Toolkit; it is a view concern. The Toolkit is 
unaware of the concept of Posses - only the Surface widget knows about them.</p>

<h5>Removing Nodes Manually</h5>

<p>You can at any time manually remove a Node from its Posse with this method:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">removeFromPosse</span><span class="p">(</span><span class="nx">aNode</span><span class="p">,</span> <span class="nx">posseId</span><span class="p">);</span>
</code></pre></div>
<p><code>aNode</code> may be the ID of a Node, an actual Node, a DOM element representing a Node, or a list-like object of any of these.</p>

<h5>Updating via the Toolkit</h5>

<p>If you call this method:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">toolkit</span><span class="p">.</span><span class="nx">updateNode</span><span class="p">(</span><span class="nx">someNode</span><span class="p">,</span> <span class="p">{</span> <span class="p">...</span> <span class="p">});</span>
</code></pre></div>
<p>The Toolkit updates its data model and then informs any Surface widgets that are attached. The Surface widgets then 
re-render the Node and run the Node&#39;s data through the <code>assignPosse</code> function, updating - or clearing - the Posse
as required.</p>

<p><a href="#top">[top]</a></p>

<hr>

<p><a id="miniview"></a></p>

<h3>The Miniview Widget</h3>

<p>Every <code>Surface</code> widget can have a <code>Miniview</code> associated with it - a small window displaying the structure of the UI, 
which is independently pannable and zoomable, and which controls the Surface&#39;s view.  It is zoomed out to such an 
extent that all of the nodes in the Surface are visible within its viewport, and contains a &quot;panner&quot; element that 
maps the current visible viewport of the Surface to which it is related.</p>

<h4>Instantiating a Miniview</h4>

<p>To get a Miniview you can either first get a Surface:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">toolkit</span> <span class="o">=</span> <span class="nx">jsPlumbToolkit</span><span class="p">.</span><span class="nx">newInstance</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElId&quot;</span>
<span class="p">});</span>
</code></pre></div>
<p>...and then ask that Surface to create a Miniview:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">miniview</span> <span class="o">=</span> <span class="nx">surface</span><span class="p">.</span><span class="nx">createMiniview</span><span class="p">({</span> 
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someMiniviewContainerId&quot;</span>  
<span class="p">});</span>
</code></pre></div>
<p>or, you can supply Miniview parameters to the <code>render</code> call and then subsequently get the Miniview from the Surface:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">toolkit</span> <span class="o">=</span> <span class="nx">jsPlumbToolkit</span><span class="p">.</span><span class="nx">newInstance</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElId&quot;</span><span class="p">,</span>
  <span class="nx">miniview</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someMiniContainerId&quot;</span>  
  <span class="p">}</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">miniview</span> <span class="o">=</span> <span class="nx">surface</span><span class="p">.</span><span class="nx">getMiniview</span><span class="p">();</span>
</code></pre></div>
<p><strong>NB</strong> These code samples show how you can retrieve a Miniview from some Surface after it has been created. In reality 
you will not need to work directly with a Miniview very often, if at all.</p>

<h4>Configuring a Miniview</h4>

<p>The size of a Miniview is something you set yourself, either through CSS, or via inline styles on the Miniview&#39;s 
<code>container</code> element. The jsPlumb Toolkit uses the size of a Miniview&#39;s <code>container</code> combined with the extents of the 
visible content in the related Surface to compute the appropriate zoom level for the Miniview.</p>

<p>The zoom wheel can be used to zoom in and out on a Surface via its associated Miniview.  When this occurs, the 
visible node set does not change - the Miniview always shows the entire dataset - but the panner element changes 
size to reflect the fact that the Nodes that are visible in the related Surface&#39;s viewport have changed.</p>

<h4>CSS</h4>

<p>These are the classes you can use to style the Miniview widget.  Note that nodes in the Miniview are sized to be 
identical to their mapped nodes in the related Surface (but the Miniview is zoomed out, so they are not 1:1 in size 
with their related nodes). You could of course use CSS to force a size for nodes in the Miniview, but this is not 
recommended; if your Surface contains nodes of various sizes but the Miniview uses a uniform size, the user may 
experience a certain discontinuity between the two views.</p>

<table>
<tr><th>Class</th><th>Description</th></tr>
<tr><td>jtk-miniview</td><td>Assigned to an element that is acting as a Miniview's container</td></tr>
<tr><td>jtk-miniview-canvas</td><td>Assigned to the work area in the Miniview</td></tr>
<tr><td>jtk-miniview-panner</td><td>Assigned to the element used to pan the Surface from the Miniview</td></tr>
<tr><td>jtk-miniview-element</td><td>Assigned to all elements on the Miniview's canvas</td></tr>
</table>

<p><a href="#top">[top]</a></p>

<hr>

<p><a id="templating"></a></p>

<h3>Templating</h3>

<p><a href="#top">[top]</a></p>

<hr>

<p><a id="interceptors"></a></p>

<h3>Drop/Detach Interceptors</h3>

<p>In jsPlumb you can attach interceptors for connection drop and connection detach; these are functions which, should 
they return false, cause the associated action to be aborted.  This is supported in the Toolkit 
via <a href="palettes.html#interceptors">interceptors in a Palette</a>.</p>

<p><a href="#top">[top]</a></p>

<hr>

<h3>Repainting Objects</h3>

<p>To force a Surface to repaint some object, you can use the <code>repaint</code> method:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">repaint</span><span class="p">(</span><span class="nx">someObject</span><span class="p">);</span>
</code></pre></div>
<p>Valid values for <code>someObject</code> are:</p>

<ul>
<li>a Toolkit Node</li>
<li>a Toolkit Port</li>
<li>a DOM element representing a Toolkit Node or Port</li>
<li>the ID of a Toolkit Node or Port</li>
<li>an element that has a Toolkit Node or Port element as an ancestor.</li>
</ul>

<p>The last item in this list might need a little explanation: the idea is that you might have made some changes to 
part of your UI and you want to repaint the Toolkit object to which it belongs. Rather than forcing you to go off and 
find the appropriate ancestor, or the id of the appropriate ancestor, you can just pass some element in here and have 
the Surface figure out what it would be best to repaint.</p>

<p><a href="#top">[top]</a></p>

<hr>

<h3>CSS Classes</h3>

<p>For a discussion of how the Toolkit handles CSS, see <a href="css.html">this page</a>.</p>

<hr>

<p><a id="saverestore"></a></p>

<h3>Saving and Restoring UI State</h3>

<p>The state of a given renderer can be written to, and subsequently read from, local storage (or a cookie, depending on 
the capabilities of the browser).  This is achieved through a few methods and/or constructor parameters:</p>

<h4>Constructor Parameters for automatically saving state</h4>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="nx">container</span><span class="o">:</span><span class="s2">&quot;someElement&quot;</span><span class="p">,</span>
  <span class="nx">saveStateOnExit</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>              <span class="c1">// serialize state on page unload automatically. defaults to false.</span>
  <span class="nx">saveStateOnDrag</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>              <span class="c1">// serialize state after each drag. defaults to false.</span>
  <span class="nx">stateHandle</span><span class="o">:</span><span class="s2">&quot;someString&quot;</span>           <span class="c1">// required for either of the auto state save options. the handle to store the state by.</span>
<span class="p">});</span>
</code></pre></div>
<h4>Methods for saving/restoring state</h4>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">saveState</span><span class="p">([</span><span class="nb">String</span> <span class="nx">handle</span><span class="p">],</span> <span class="p">[</span><span class="nb">Function</span> <span class="nx">preprocessor</span><span class="p">]);</span>
</code></pre></div>
<p>Saves the state with the given handle. If handle is not supplied but <code>stateHandle</code> was provided as a constructor 
parameter, that value is used.  If neither is supplied then the state is not saved.</p>

<p>The optional <code>preprocessor</code> argument allows you to pre-process the data loaded from localStorage before it is applied
to the Surface. This could be used for many things, but the main intended usage for this mechanism is to allow you
to apply compression/decompression to the data that is placed into localStorage. Limits vary, but at the time of writing
you could consider as a rough guide that the limit on data that can be placed in localStorage is about 5MB.</p>

<p>The <code>preprocessor</code> function must take two arguments:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
</code></pre></div>
<p>and is required to call <code>callback</code> with the pre-processed data. As a spurious example, maybe you want to prepend a 
timestamp to the data before storing:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">save</span><span class="p">(</span><span class="s2">&quot;myHandle&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">callback</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">data</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>Or perhaps you might decide to use the <a href="https://github.com/nmrugg/LZMA-JS/">LZMA library</a> to compress your data. The 
<code>compress</code> method of LZMA has this signature:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">compress</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">[</span><span class="nx">level</span><span class="p">],</span> <span class="nx">callback</span><span class="p">);</span>
</code></pre></div><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">save</span><span class="p">(</span><span class="s2">&quot;myHandle&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">LZMA</span><span class="p">.</span><span class="nx">compress</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>Notice here that we passed <code>callback</code> directly to LZMA; it wasn&#39;t necessary to wrap it in another function.</p>

<p>Note that you can call this method with the <code>preprocessor</code> as the single argument, since the Surface can figure out
that if you supply a Function it is not a handle with which to save the data.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">restoreState</span><span class="p">(</span><span class="nb">String</span> <span class="nx">handle</span><span class="p">,</span> <span class="p">[</span><span class="nb">Function</span> <span class="nx">preprocessor</span><span class="p">]);</span>
</code></pre></div>
<p>Restores the state with the given handle. If handle is not supplied but <code>stateHandle</code> was provided as a constructor 
parameter, that value is used.  If neither is supplied then the state is not restored.</p>

<p>See the note on <code>saveState</code> for a discussion of the optional <code>preprocessor</code> Function. Note also that you can call 
this method with the <code>preprocessor</code> as the single argument, since the Surface can figure out
that if you supply a Function it is not a handle with which to save the data.</p>

<p>This might be the matching decompression preprocessor you&#39;d use for the timestamp example above:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">restore</span><span class="p">(</span><span class="s2">&quot;myHandle&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">parts</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/^([0-9]+)(?:-)/</span><span class="p">),</span>
      <span class="nx">timestamp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="p">));</span>

  <span class="nx">callback</span><span class="p">(</span><span class="nx">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">});</span>
</code></pre></div>
<p>For the LZMA decompression example, you could do this:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">save</span><span class="p">(</span><span class="s2">&quot;myHandle&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">LZMA</span><span class="p">.</span><span class="nx">decompress</span><span class="p">(</span><span class="nx">layout</span><span class="p">.</span><span class="nx">payload</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">clearState</span><span class="p">([</span><span class="nb">String</span> <span class="nx">handle</span><span class="p">]);</span>
</code></pre></div>
<p>Clears the state stored with the given handle. If handle is not supplied but <code>stateHandle</code> was provided as a constructor parameter, that value is used.  If neither is supplied then the state is not cleared.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">serialize</span><span class="p">();</span>
</code></pre></div>
<p>Serialize the state of the Surface and return the serialized string. This is of course the method that <code>saveState</code> uses
internally.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"> <span class="nx">deserialize</span><span class="p">(</span><span class="nb">String</span> <span class="nx">serializedData</span><span class="p">);</span>
</code></pre></div>
<p>Deserialize the state of the Surface from the given string. This is of course the method that <code>restoreState</code> uses
 internally. </p>

<h4>Saving and Restoring Custom Properties</h4>

<p>The Surface widget exposes the functionality used to save/restore state as four methods that you can call to store arbitrary data of your own:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">store</span><span class="p">({</span><span class="nb">String</span><span class="p">}</span> <span class="nx">handle</span><span class="p">,</span> <span class="p">{</span><span class="nb">String</span><span class="p">}</span> <span class="nx">data</span><span class="p">);</span>
</code></pre></div>
<p>Stores a string using the provided handle as the key.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">storeJSON</span><span class="p">({</span><span class="nb">String</span><span class="p">}</span> <span class="nx">handle</span><span class="p">,</span> <span class="p">{</span><span class="nb">Object</span><span class="p">}</span> <span class="nx">data</span><span class="p">);</span>
</code></pre></div>
<p>Stores an object using the provided handle as the key. This method actually serializes the given object to a string, 
and therefore expects that there is a global <code>JSON</code> object available in the browser, which is true of many modern 
browsers, and is also provided by jQuery. If <code>JSON</code> is not available in the browser this method fails silently.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span><span class="nb">String</span><span class="p">}</span> <span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">retrieve</span><span class="p">({</span><span class="nb">String</span><span class="p">}</span> <span class="nx">handle</span><span class="p">);</span>
</code></pre></div>
<p>Retrieves a string using the provided handle as the key. Will return null if nothing is stored against the given 
handle.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span><span class="nb">Object</span><span class="p">}</span> <span class="nx">surface</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nx">retrieveJSON</span><span class="p">({</span><span class="nb">String</span><span class="p">}</span> <span class="nx">handle</span><span class="p">,</span> <span class="p">{</span><span class="nb">Object</span><span class="p">}</span> <span class="nx">data</span><span class="p">);</span>
</code></pre></div>
<p>Retrieves an object using the provided handle as the key. See the note above about the required <code>JSON</code> dependency. 
Will return null if nothing is stored against the given handle.</p>

<p><a href="#top">[top]</a></p>

<hr>

<p><a id="dragpalette"></a></p>

<h3>Dragging Nodes from a Palette</h3>

<p>A common use case for applications using the jsPlumb Toolkit is the requirement for a palette of nodes from which items can be dragged into the work area. The Surface widget has a method that supports this for elements in your UI, as well as - in browsers that support it - items dragged from the file system.</p>

<h4>Configuring a Node Palette</h4>

<p>The Toolkit makes no assumptions about the structure of your node palette - you create the palette yourself, using 
whatever markup you like, and then you supply to the Toolkit either a selector it can use to identify draggable nodes or
  a list of elements. This is an example from the Database Visualizer application:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">toolkit</span> <span class="o">=</span> <span class="nx">jsPlumbToolkit</span><span class="p">.</span><span class="nx">newInstance</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">renderer</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">render</span><span class="p">(...</span><span class="nx">params</span><span class="p">...);</span>

<span class="nx">renderer</span><span class="p">.</span><span class="nx">registerDroppableNodes</span><span class="p">({</span>
  <span class="nx">droppables</span><span class="o">:</span><span class="nx">nodePalette</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&quot;li&quot;</span><span class="p">),</span> 
  <span class="nx">dragOptions</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">zIndex</span><span class="o">:</span><span class="mi">50000</span><span class="p">,</span>
    <span class="nx">cursor</span><span class="o">:</span><span class="s2">&quot;move&quot;</span><span class="p">,</span>
    <span class="nx">clone</span><span class="o">:</span><span class="kc">true</span>
  <span class="p">},</span>
  <span class="nx">typeExtractor</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">dropInfo</span><span class="p">,</span> <span class="nx">isNative</span><span class="p">,</span> <span class="nx">eventLocation</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span>  <span class="nx">el</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&quot;jtk-node-type&quot;</span><span class="p">);</span> 
  <span class="p">},</span> 
  <span class="nx">dataGenerator</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">dragElement</span><span class="p">,</span> <span class="nx">dropInfo</span><span class="p">,</span> <span class="nx">eventLocation</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span><span class="nx">type</span> <span class="p">};</span> <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>The parameters to this method are:</p>

<ul>
<li><strong>droppables</strong> Provides the individual nodes that should be draggable. You can also provide <code>source</code> and <code>selector</code>, which
is a better option for some use cases as you can subsequently <code>refresh</code> the handler to add more droppables.</li>
<li><strong>dragOptions</strong> Optional values to pass through to the underlying code that makes nodes draggable.</li>
<li><strong>typeExtractor</strong> This function takes an element and returns to the Toolkit the type of node that is represented by that element. In this application, that information is stored in the <code>jtk-node-type</code> attribute of each element. The <code>typeExtractor</code> is optional; if not supplied, it will be assumed that the Node type is <code>default</code>.</li>
<li><strong>dataGenerator</strong> This function takes four arguments and returns some default data for that Node type.

<ul>
<li><strong>type</strong> - type of the dropped node. <strong>Note</strong> that <code>type</code> might be null: if a <code>typeExtractor</code> function was not provided this will be the case, but also it may be the case that your <code>typeExtractor</code> returns null. So you should program defensively in this function. Note also that this function is again optional; if not provided then a Node is initialised with an empty object as its backing data.</li>
<li><strong>dragElement</strong> - the element that was dragged and dropped. Perhaps you have marked this up with a set of attributes that describe what you want to do when it is dropped.</li>
<li><strong>dropInfo</strong> - An object containing the underlying Drag, Drop and mouse event. Not something most applications will need to use.</li>
<li><strong>eventLocation</strong> An object containing <code>{ left:.., top:... }</code> values that provides the location on the canvas at which the drop occurred.</li>
</ul></li>
</ul>

<p>The example from above but using <code>source</code> and <code>selector</code> might look like:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="nx">renderer</span><span class="p">.</span><span class="nx">registerDroppableNodes</span><span class="p">({</span>
  <span class="nx">source</span><span class="o">:</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;nodePalette&quot;</span><span class="p">),</span>
  <span class="nx">selector</span><span class="o">:</span><span class="s2">&quot;li&quot;</span><span class="p">,</span> 
  <span class="nx">dragOptions</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">zIndex</span><span class="o">:</span><span class="mi">50000</span><span class="p">,</span>
    <span class="nx">cursor</span><span class="o">:</span><span class="s2">&quot;move&quot;</span><span class="p">,</span>
    <span class="nx">clone</span><span class="o">:</span><span class="kc">true</span>
  <span class="p">},</span>
  <span class="nx">typeExtractor</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">dropInfo</span><span class="p">,</span> <span class="nx">isNative</span><span class="p">,</span> <span class="nx">eventLocation</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span>  <span class="nx">el</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&quot;jtk-node-type&quot;</span><span class="p">);</span> 
  <span class="p">},</span> 
  <span class="nx">dataGenerator</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">dragElement</span><span class="p">,</span> <span class="nx">dropInfo</span><span class="p">,</span> <span class="nx">eventLocation</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span><span class="nx">type</span> <span class="p">};</span> <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>As mentioned, the benefit of this is that the return value has a <code>refresh</code> method you can use if you add more 
 elements that you need to be droppable:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"> <span class="nx">handler</span><span class="p">.</span><span class="nx">refresh</span><span class="p">();</span>
</code></pre></div>
<p>The <code>selector</code> will be run against <code>source</code> again, and any new elements that are encountered will be configured as
 droppables using the same parameters.</p>

<h6>Drag Clones</h6>

<p>One important point to note here is that in the <code>dragOptions</code> we have set <code>clone:true</code>. This is how, in Katavorio (the
 drag library used by the Toolkit) you say you want to drag a copy of the original item and not the item itself, 
 and is most likely what you will want for your application. </p>

<h6>Drag CSS</h6>

<p>You should ensure that the drag clone is positioned absolute.</p>

<p><a id="dragnative"></a></p>

<h3>Dragging Native Objects</h3>

<p>The Surface renderer also supports drag and drop of native objects - if the browser in which the Toolkit is running supports it. 
Let&#39;s add support for native drag/drop to the example from before:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">toolkit</span> <span class="o">=</span> <span class="nx">jsPlumbToolkit</span><span class="p">.</span><span class="nx">newInstance</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">renderer</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">render</span><span class="p">(...</span><span class="nx">params</span><span class="p">...);</span>

<span class="nx">renderer</span><span class="p">.</span><span class="nx">registerDroppableNodes</span><span class="p">({</span>
  <span class="nx">dragOptions</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">zIndex</span><span class="o">:</span><span class="mi">50000</span><span class="p">,</span>
    <span class="nx">cursor</span><span class="o">:</span><span class="s2">&quot;move&quot;</span><span class="p">,</span>
    <span class="nx">clone</span><span class="o">:</span><span class="kc">true</span>
  <span class="p">},</span>
  <span class="nx">typeExtractor</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">event</span><span class="p">,</span> <span class="nx">isNative</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="nx">isNative</span><span class="o">?</span> <span class="nx">event</span><span class="p">.</span><span class="nx">dataTransfer</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">el</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&quot;jtk-node-type&quot;</span><span class="p">);</span> 
  <span class="p">},</span> 
  <span class="nx">dataGenerator</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">dragElement</span><span class="p">,</span> <span class="nx">dropInfo</span><span class="p">,</span> <span class="nx">eventLocation</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span><span class="nx">type</span> <span class="p">};</span> <span class="p">},</span>
  <span class="nx">allowNative</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>
  <span class="nx">nativeFilter</span><span class="o">:</span><span class="p">[</span> <span class="s2">&quot;image/jpeg&quot;</span><span class="p">,</span> <span class="s2">&quot;image/png&quot;</span> <span class="p">]</span>
<span class="p">});</span>
</code></pre></div>
<p>The three things to note here are:</p>

<ul>
<li><strong>allowNative</strong> is the flag used to switch on native drag/drop (it is off by default)</li>
<li><strong>nativeFilter</strong> is an optional array of MIME types for supported objects. If this is not provided then any object is allowed to be dropped.</li>
<li>The <strong>typeExtractor</strong> function is passed a third argument, which, if true, indicates that a native object was dropped.  In that case the value of <code>el</code> is a placeholder element that jsPlumb has used for dragging, and holds nothing of interest to you.  You will be interested in the <code>dataTransfer</code> property of the event.</li>
</ul>

<p><a href="#top">[top]</a></p>

<hr>

<p><a id="misc"></a></p>

<h3>Suspending Event Consumption</h3>

<p>By default, the Surface will consume any right click events it catches. You can turn this off, which is handy when developing, in one of two ways:</p>

<ul>
<li>Supply a parameter to the render call:</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">surface</span> <span class="o">=</span> <span class="nx">toolkit</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
  <span class="p">...</span>
  <span class="nx">consumeRightClick</span><span class="o">:</span><span class="kc">false</span><span class="p">,</span>
  <span class="p">...</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li>Call this method on an existing Surface:</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">surface</span><span class="p">.</span><span class="nx">setConsumeRightClick</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
</code></pre></div>
<p><a id="disable"></a></p>

<h3>Disabling a Surface</h3>

<p>To temporarily &quot;switch off&quot; a Surface (ie. have it stop responding to mouse events), you can use the <code>setEnabled</code> method:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">renderer</span><span class="p">.</span><span class="nx">setEnabled</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="p">...</span> <span class="nx">time</span> <span class="nx">passes</span><span class="p">,</span> <span class="nx">things</span> <span class="nx">happen</span><span class="p">....</span>
<span class="nx">renderer</span><span class="p">.</span><span class="nx">setEnabled</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</code></pre></div>
<p><a id="ie8"></a></p>

<h3>IE8 Limitations</h3>

<p>The jsPlumb Toolkit renders to IE8 but with a few limitations:</p>

<ul>
<li>Animations are not supported. </li>
<li>Zooming is not supported.</li>
<li>Performance is quite limited. It is not a good idea to try to load very large datasets.</li>
</ul>

                </div>
            </div>
        </div>

    </body>

</html>
